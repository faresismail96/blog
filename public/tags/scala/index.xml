<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>scala on Learning Publicly</title>
    <link>https://fares.codes/tags/scala/</link>
    <description>Recent content in scala on Learning Publicly</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 07 Aug 2022 21:00:00 +0100</lastBuildDate><atom:link href="https://fares.codes/tags/scala/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Cats Effect Part One: Effects</title>
      <link>https://fares.codes/posts/cats-effect-part-one-effects/</link>
      <pubDate>Sun, 07 Aug 2022 21:00:00 +0100</pubDate>
      
      <guid>https://fares.codes/posts/cats-effect-part-one-effects/</guid>
      <description>Cats Effect Series For some time now, I&amp;rsquo;ve been meaning to learn about cats effect. My plan is to follow the Essential Effects by Adam Rosien You can find a copy of the book here: https://essentialeffects.dev/ Though at the time of writing, the book is still in draft version.
I will be summarizing my understanding of each chapter in blog posts (chapter by chapter). I will also be solving and posting some of their exercises.</description>
    </item>
    
    <item>
      <title>Single Abstract Method</title>
      <link>https://fares.codes/posts/single-abstract-method/</link>
      <pubDate>Mon, 04 Apr 2022 20:20:00 +0200</pubDate>
      
      <guid>https://fares.codes/posts/single-abstract-method/</guid>
      <description>Short and quick article to explain a syntactic sugar in Scala.
Often we&amp;rsquo;ll have traits that declare a single abstract method to be overridden in the subclasses of that trait.
This might look like this:
sealed trait Animal{ def sayHi(name: String): String } object Animal{ final case object Dog { override def siHi(name: String): String = s&amp;#34;Woof $name&amp;#34; } } But we can also instantiate anonymous classes that implement the trait Animal:</description>
    </item>
    
    <item>
      <title>Property Based Testing with ScalaCheck</title>
      <link>https://fares.codes/posts/property-based-testing-with-scalacheck/</link>
      <pubDate>Sun, 28 Feb 2021 19:20:00 +0200</pubDate>
      
      <guid>https://fares.codes/posts/property-based-testing-with-scalacheck/</guid>
      <description>Unit testing is an effective way of catching bugs and protecting our code from future bugs related to refactoring.
But with the classical unit tests (example based tests), we are restricted to the test cases we can think ok. We can only write a finite number of tests that cover a finite number of cases.
In this article I&amp;rsquo;ll begin by showing the limitations of example based tests before moving to scalacheck and property based testing.</description>
    </item>
    
    <item>
      <title>ADTs: Sum Types and Product Types</title>
      <link>https://fares.codes/posts/adts-sum-types-and-product-types/</link>
      <pubDate>Sun, 14 Feb 2021 12:20:00 +0200</pubDate>
      
      <guid>https://fares.codes/posts/adts-sum-types-and-product-types/</guid>
      <description>It has been a while since I haven&amp;rsquo;t posted a new article, and in an attempt to break the cycle I&amp;rsquo;m starting off with something pretty simple.
When listening to people talk of ADTs, you&amp;rsquo;ll often hear the words: Sum type and Product type. Now I have a bad habit of confusing the two so in this article I&amp;rsquo;ll attempt to make things clearer and I will hopefully never find myself re-re-researching both.</description>
    </item>
    
    <item>
      <title>Reader Monads and Dependency Injection</title>
      <link>https://fares.codes/posts/reader-monads-and-dependency-injection/</link>
      <pubDate>Sun, 29 Nov 2020 20:37:00 +0100</pubDate>
      
      <guid>https://fares.codes/posts/reader-monads-and-dependency-injection/</guid>
      <description>After writing an article about the Writer Monad, it only seems fair that I write another one about the Reader Monad.
As with the Writer article, my main support will be the Scala with Cats Underscore Book freely available online.
I&amp;rsquo;ve also decided to put more effort into my examples and have them answer a real life problem. So in this articles&amp;rsquo; examples, I&amp;rsquo;ll attempt to answer a common life question: &amp;ldquo;Can I become friends with x person&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Writer Monads</title>
      <link>https://fares.codes/posts/writer-monads/</link>
      <pubDate>Sun, 04 Oct 2020 23:00:00 +0200</pubDate>
      
      <guid>https://fares.codes/posts/writer-monads/</guid>
      <description>This is actually one of the very first GitHub tickets I&amp;rsquo;ve opened. I tend read medium articles on my daily commute to work and I always see articles on the Writer Monad (along other monad instances I plan to write about). I did not use to read them because they&amp;rsquo;re topics I do not understand but I&amp;rsquo;ve been meaning to learn about them for a while now&amp;hellip; And so here is goes:</description>
    </item>
    
    <item>
      <title>Cats MonadError</title>
      <link>https://fares.codes/posts/cats-monaderror/</link>
      <pubDate>Fri, 25 Sep 2020 06:20:00 +0200</pubDate>
      
      <guid>https://fares.codes/posts/cats-monaderror/</guid>
      <description>I&amp;rsquo;ve been mostly focusing on Python for the past couple weeks so I&amp;rsquo;ll attempt to balance things out by prioritizing a couple Scala articles&amp;hellip;
I&amp;rsquo;ve also come to realize that I have not been following the methodology that has inspired this blog in the first place. In this article, I&amp;rsquo;ll attempt to constantly answer the question &amp;ldquo;why&amp;rdquo; and in doing so hopefully strengthen my grasp of the subject . And so for all my readers, the both of you might notice a change in format üòù.</description>
    </item>
    
    <item>
      <title>Cats Kleisli</title>
      <link>https://fares.codes/posts/cats-kleisli/</link>
      <pubDate>Sun, 17 May 2020 10:00:00 +0200</pubDate>
      
      <guid>https://fares.codes/posts/cats-kleisli/</guid>
      <description>I wont lie&amp;hellip; The main reason I&amp;rsquo;m looking into Kleisli is because I think the name is cool.
Kleisli allows the composition of functions where the return type is a monadic value while the input to the next function is not.
Function Composition Function Composition allows us to chain function calls together.
Here is a dummy example:
val getValueFromDB: Unit =&amp;gt; String = _ =&amp;gt; &amp;#34;Fares&amp;#34; val transformValue: String =&amp;gt; String = _.</description>
    </item>
    
    <item>
      <title>Scala Sealed Trait vs Sealed Abstract Class</title>
      <link>https://fares.codes/posts/scala-sealed-trait-vs-sealed-abstract-class/</link>
      <pubDate>Sun, 03 May 2020 20:00:00 +0200</pubDate>
      
      <guid>https://fares.codes/posts/scala-sealed-trait-vs-sealed-abstract-class/</guid>
      <description>From my previous articles, you&amp;rsquo;ve seen me create ADTs in two different ways:
sealed abstract class Animal object Animal { final case object Dog extends Animal final case object Cat extends Animal } or
sealed trait Animal object Animal { final case object Dog extends Animal final case object Cat extends Animal } This article will outline the difference between those two implementations.
Sealed Trait If a behavior is to be re-used, traits are very handy since they can be mixed in.</description>
    </item>
    
    <item>
      <title>Smart Constructors in Scala</title>
      <link>https://fares.codes/posts/smart-constructors-in-scala/</link>
      <pubDate>Sun, 03 May 2020 10:00:00 +0200</pubDate>
      
      <guid>https://fares.codes/posts/smart-constructors-in-scala/</guid>
      <description>Assume we have the following ADT:
sealed trait Person { def name: String def age: Int } object Person { final case class Adult(name: String, age: Int, fieldOfWork: String) extends Person final case class Child(name: String,age: Int, favAnimal: String) extends Person } Probably a very naive way to see humanity but for our example, it&amp;rsquo;ll do.
So a Person can either be an Adult with a field of work or a Child with a favorite animal.</description>
    </item>
    
    <item>
      <title>PureConfig From A to F</title>
      <link>https://fares.codes/posts/pureconfig-from-a-to-f/</link>
      <pubDate>Mon, 13 Apr 2020 10:00:00 +0000</pubDate>
      
      <guid>https://fares.codes/posts/pureconfig-from-a-to-f/</guid>
      <description>If you&amp;rsquo;re saying to yourself: &amp;ldquo;Surely theres a typo here&amp;hellip; Its normally From A to Z&amp;rdquo;, yes&amp;hellip; but since I have much left to learn in pureconfig, well stop at F üòâ
Sometimes I write useless articles (cond or cats show) and in other times, I write something slightly more interesting and useful üòÉ
PureConfig allows us to quickly and easily load configurations from config files in a type safe and boiler plate free manner.</description>
    </item>
    
    <item>
      <title>Cats Chain</title>
      <link>https://fares.codes/posts/cats-chain/</link>
      <pubDate>Fri, 03 Apr 2020 10:00:00 +0000</pubDate>
      
      <guid>https://fares.codes/posts/cats-chain/</guid>
      <description>In previous articles, I&amp;rsquo;ve talked about accumulating errors with Validated, and for that we said that we needed a Semigroup on the left side that will be used to accumulate the errors (We used a NonEmptyList[A] as an example). Today well talk about Chain and NonEmptyChain[A] and how it&amp;rsquo;s different from a List.
Appending to a List requires iterating over the entire collection (linear time). So using ValidatedNel[A,B] will make us incur a heavy performance penalty specially if we traverse it.</description>
    </item>
    
    <item>
      <title>Cond in Scala</title>
      <link>https://fares.codes/posts/cond-in-scala/</link>
      <pubDate>Tue, 31 Mar 2020 01:00:00 +0000</pubDate>
      
      <guid>https://fares.codes/posts/cond-in-scala/</guid>
      <description>This is probably one of the simplest articles I&amp;rsquo;ve written&amp;hellip; except for the About section of this site&amp;hellip;
The reason I&amp;rsquo;m writing it is because I recently discovered a simple yet very useful function that facilitates the construction of an Either monad or a Validated monad.
This function is called cond probably short for condition. Ans here is how it works:
import cats.data.Validated def someFunction: Boolean = ??? val either: Either[String, String] = Either.</description>
    </item>
    
    <item>
      <title>Cats Bifunctor</title>
      <link>https://fares.codes/posts/cats-bifunctor/</link>
      <pubDate>Sun, 09 Feb 2020 10:00:00 +0000</pubDate>
      
      <guid>https://fares.codes/posts/cats-bifunctor/</guid>
      <description>The following will be a short and rather simple article about a useful function I recently learned about: bimap by cats.
In cats and in some cases scala, types like Either, Validated, Option&amp;hellip; are right biased. which means that when we call .map on them, the function applied in the map is only applied on the case of a right.
Here are some examples:
val either: Either[String, Int] = Right(2) val result: Either[String, Int] = either.</description>
    </item>
    
    <item>
      <title>Value Classes in Scala</title>
      <link>https://fares.codes/posts/value-classes-in-scala/</link>
      <pubDate>Fri, 04 Oct 2019 20:55:00 +0000</pubDate>
      
      <guid>https://fares.codes/posts/value-classes-in-scala/</guid>
      <description>Before we look into value classes, lets start by why we might need them in the first place.
case class Client(id: Int, name: String) case class BankAccount(id: Int, clientId: Int, amount: Double) val account1 = BankAccount(1,1,100) val account2 = BankAccount(2,1,200) val account3 = BankAccount(1,2,1000) val client1 = Client(1,&amp;#34;Danny&amp;#34;) val client2 = Client(2, &amp;#34;Emily&amp;#34;) In this example, we have three bank accounts, two belonging to Danny and one to Emily.
Now we add a function that checks if two bank accounts belong to the same client:</description>
    </item>
    
    <item>
      <title>Fold vs Pattern Matching and Matching on Options</title>
      <link>https://fares.codes/posts/fold-vs-pattern-matching-and-matching-on-options/</link>
      <pubDate>Sun, 01 Sep 2019 10:00:00 +0000</pubDate>
      
      <guid>https://fares.codes/posts/fold-vs-pattern-matching-and-matching-on-options/</guid>
      <description>The following article is a summary of the Lambda Conf 2015 talk: Idiomatic Scala Your Options Do Not Match by Marconi Lanna https://www.youtube.com/watch?v=ol2AB5UN1IA&amp;amp;t=1s
Often when dealing with Options, we have a case where we want to check if a value is defined and if it is, apply a specific treatment on the value inside the option. So we end up with a code that looks something like this:
value match { case Some(a) =&amp;gt; foo(a) case None =&amp;gt; bar } In this example, we patten match on the Option value.</description>
    </item>
    
    <item>
      <title>Un-Apply in Scala</title>
      <link>https://fares.codes/posts/un-apply-in-scala/</link>
      <pubDate>Fri, 02 Aug 2019 10:10:00 +0000</pubDate>
      
      <guid>https://fares.codes/posts/un-apply-in-scala/</guid>
      <description>Unapply in Scala is the inverse of the apply&amp;hellip; (queue no shit comments :p)
So what does it do exactly? given a class Person:
case class Person(name: String, age: Int, hobbies: List[String]) If we wanted to decompose the class person into a set of attributes:
name: String age: Int hobbies: List[String] We would use the unapply. the return type of the unapply is an Option of a tuple with the values inside the tuple representing the values we seek to retrieve.</description>
    </item>
    
    <item>
      <title>For Comprehensions Demystified</title>
      <link>https://fares.codes/posts/for-comprehensions-demystified/</link>
      <pubDate>Mon, 29 Jul 2019 21:37:00 +0000</pubDate>
      
      <guid>https://fares.codes/posts/for-comprehensions-demystified/</guid>
      <description>A For Comprehension is a syntactic sugar for using a composition of map, flatMap and filter.
At first glance it might look complicated and difficult to comprehend. But once you get the hang of it, you&amp;rsquo;ll realise it&amp;rsquo;s a cool card to have up your sleeve, one that will surely make your code much more readable.
Lets look at the below couple functions:
def computeA(a: Int): Either[Throwable, Int] = ??? def computeB(b: Int): Either[Throwable, Int] = ?</description>
    </item>
    
  </channel>
</rss>
